# 数据库

```mysql
create database db2019 DEFAULT CHARSET utf8 COLLATE utf8_general_ci;

use db2019;
create table `payment`(
    `id` bigint(20) not null auto_increment,
    `serial` varchar(200) default  '',
    primary key (`id`)
) engine=innodb auto_increment=1 default charset utf8;

insert into payment (id, serial) values (31,'尚硅谷001');
select * from payment;
```

# P21
## 无法访问http://eureka7002.com:7002/eureka/

别忘了修改host，以及别忘了修改` register-with-eureka: true`参数

以及先开eureka再启动

# P22

## unknownhost异常
1. 此时在cloud-provider-payment8001/8002 先把`@EnableDiscoveryClient`注解关了
2. 在`cloud-consumer-order80`工程里，先把`spring-cloud-starter-zipkin`这个依赖关了，否则找不到服务。

tmd补充，我发现又发现，即使不改也能得到结果。奇了怪了。
补充 应该是有延时

# p28

```shell
docker pull zookeeper:3.4.14
docker run -d -e TZ="Asia/Shanghai" -p 2181:2181 --name zookeeper3.4.14 --restart always zookeeper:3.4.14
```

视频之中说的jar包冲突是因为：报了unimplement异常，说明这个jar包不对，那就换成3.4.x版本的jar

服务注册成功之后，登陆进去看一下
```shell
/zookeeper-3.4.14/bin/zkCli.sh

ls /services/cloud-provider-payment
get /services/cloud-provider-payment/xxxxxx
```

# p32

```shell
docker run -d -p 8500:8500 --restart=always --name consul:1.6.10 consul:1.6.10 agent -server -bootstrap -ui -node=1 -client='0.0.0.0'

docker run --name consul1.6.10 -d -p 8500:8500 -p 8300:8300 -p 8301:8301 -p 8302:8302 -p 8600:8600 consul:1.6.10 agent -server -bootstrap-expect=1 -ui -bind=0.0.0.0 -client=0.0.0.0
```
登陆进去不用执行`consul agent -dev`

# p36
- 集中式LB：nginx 例如外部来了http请求，nginx负责分发到不同的机器上；
- 进程式LB：ribbon 在程序内做rpc调用的时候，将这个调用分发到不同微服务上。
- LB：其实都是LB，只不过用的地方不一样，前者面向外部，后者是服务内部各个微服务之间的调用

# p38
`RibbonClient`这个注解源码有清晰的注释；

# p42
此时首先要把`restTemplate`的`loadBalance`注解关了，这节的意义在于手动地实现负载均衡；当然= =此时`http://localhost:80/consumer/payment/get/31` 就失效了

# p47
问题：由于微服务是拆分的，拆分导致了复杂的依赖关系；如果某个服务S被多个服务直接依赖或者间接依赖，当服务S出现了问题，所有依赖这个服务的服务都会受到影响，例如调用超时、调用线程持续等待，就雪崩了；

# p51



jmeter配置图

![image-20220130144224612](笔记.assets/image-20220130144224612.png)

此实验先把`@EnableCircuitBreaker`给注释掉



# P51

这一节的例子是模拟8001背压垮，然后消费端80调用ok接口受到影响；记得把`PaymentHystrixService`的`fallback = PaymentFallbackService.class`注释掉；并且把`EnableHystrix`注释了



# p53

这块服务降级主要是为了不要再访问这个服务了，防止多个线程因为这个坏节点而卡死，防止雪崩，保护服务器；



# p54



在下面的配置里，

```java
@HystrixCommand(fallbackMethod = "paymentInfo_TimeOutHandler",commandProperties = {
            @HystrixProperty(name="execution.isolation.thread.timeoutInMilliseconds",value="3000")
    })
    public String paymentInfo_TimeOut(Integer id)
    {
        //int age = 10/0;
        try { TimeUnit.MILLISECONDS.sleep(5000); } catch (InterruptedException e) { e.printStackTrace(); }
        return "线程池:  "+Thread.currentThread().getName()+" id:  "+id+"\t"+"O(∩_∩)O哈哈~"+"  耗时(秒): ";
    }
```

执行时会走进`catch`阶段，然后会报下一个异常。说明实现也是用中断来中止线程的。

```java
java.lang.InterruptedException: sleep interrupted
	at java.lang.Thread.sleep(Native Method)
```



# P55

视频中说了支付侧降级还是订单侧降级，实际上无论放在哪里，降级指的都是一个微服务，当某个接口在内部发生异常的时候，直接返回一些默认的结果，例如fallback；放在订单侧，就是订单侧返回异常，放在支付侧，就是支付侧返回异常。



# P57

这块使用了`FeignClient`的`fallback`，这块处理失败的逻辑应该是与ribbon的失败规则相同。因为调用time接口时，超过1s就会报错；


# P62
图里的construct和run我理解应该是真实的服务方法，就是例子里的service方法，例如`paymentCircuitBreaker`



# p64

`[Hystrix Dashboard](http://127.0.0.1:9001/hystrix)`





# P66

网关位于nginx后面，我个人理解，就是将不同的请求，根据请求的路径等规则，发送到不同的微服务身上；nginx不关注业务，关注负载均衡；而网关关注这个请求到底需要发送到哪个微服务上；



# p68

- predicate：用于判断是否匹配，匹配才会转发；
- filter：对一些匹配的、要转发的请求进行一些特定的过滤、一些pre；



# p71

通过这一节可以印证，gateway需要实现路由功能，也就是分发，将这次请求根据路由规则，分发到对应的微服务身上；以openfeign为例，调用方调用微服务的时候，是根据对方的服务名，调起相应的服务，但在gateway里，相当于将各个微服务都注册到这个网关上，调用方的所有的请求都与网关交互，网关根据路由规则，将这个请求自动地发送到对应的微服务，相当于gateway就是维护了调用微服务的规则。

对比nginx，nginx做的就仅仅是负载均衡轮询分发。





# P74



```shell
docker pull rabbitmq:3.4.3-management
docker run -d --name sgg-cloud-rabbitmq -p 5672:5672 -p 15672:15672 --hostname sggCloudRabbit rabbitmq:3.4.3-management
```



# P75

访问地址`[localhost:3344/config-prod.yml](http://localhost:3344/config-prod.yml)`就可以直接访问得到，因为如下配置已经写好了，上述网址会自动在这个git下的label指定的分支，并且在`atguigu2020/spring-cloud-config`这个路径之下进行搜索`config-prod.yml`这个文件；

```yml
server:
        git:
          uri: https://github.com/dominic-z/hello-spring-cloud.git #GitHub上面的git仓库名字
        ####搜索目录
          search-paths:
            - atguigu2020/spring-cloud-config
      ####读取分支
      label: learn/20220130-sgg-spring-cloud
```

当然`[localhost:3344/atguigu2020/spring-cloud-config/master/config-prod.yml](http://localhost:3344/atguigu2020/spring-cloud-config/master/config-prod.yml)`这个路径也能访问到，但是呢可以看得出来，这种访问方式，对于分支里带`/`的，不是很友好，可能根本访问不到。





# P76

bootstrap优先级更高，p76的4分04秒的视频里的文字有两者的区别；



# P77

post to `localhost:3355/actuator/refresh`



# p78

可以登录`[RabbitMQ Management](http://localhost:15672/#/exchanges)`就可以看到一个`springCloudBus`的exchange

老师用的是3.7，不过无所谓，大差不差



# P81

Post `http://localhost:3344/actuator/bus-refresh`



# P82



# P87

下面的配置是是说，`output`这个binding（绑定关系）绑定在`defaultRabbit`这个Rabbit上

```yml
stream:
        binders: # 在此处配置要绑定的rabbitmq的服务信息；
          defaultRabbit: # 表示定义的名称，用于于binding整合
            type: rabbit # 消息组件类型
            environment: # 设置rabbitmq的相关的环境配置
              spring:
                rabbitmq:
                  host: localhost
                  port: 5672
                  username: guest
                  password: guest
        bindings: # 服务的整合处理
          output: # 这个名字是一个通道的名称
            destination: studyExchange # 表示要使用的Exchange名称定义
            content-type: application/json # 设置消息类型，本次为json，文本则设置“text/plain”
            binder: defaultRabbit # 设置要绑定的消息服务的具体设置
```



注入bean，下面这个bean是通过`@EnableBinding(Source.class)`这个注解激活的，之所以能注入，是因为配置里绑定关系的名称叫做`output`，并且

```java
@Resource
    private MessageChannel output; // 消息发送管道
```

`Source.class`这个类里刚好名称为output`

```java
public interface Source {
    String OUTPUT = "output";

    @Output("output")
    MessageChannel output();
}
```



# P89

视频里提到的组`group`，对应的概念就是rabbitMQ里的`Queue`，由于没指定`group`，因此两个消费者有各自的queue

![image-20220131094458254](笔记.assets/image-20220131094458254.png)





# P91

视频里说的是如果没有group，这几个队列是非持久化的。

# P96



```shell
docker pull nacos/nacos-server:1.4.2

docker run -d -p 8848:8848 --env MODE=standalone  --name sgg-nacos1.4.2  nacos/nacos-server:1.4.2
```

